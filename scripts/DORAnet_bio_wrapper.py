from rdkit import Chem, DataStructs
from rdkit.Chem import rdFingerprintGenerator, rdFMCS
import warnings
from typing import Tuple, List, Union
import doranet.modules.enzymatic as enzymatic
import doranet.modules.post_processing as post_processing

warnings.simplefilter('ignore')

def calculate_Tanimoto_similarity(smiles_1: str,
                                  smiles_2: str) -> float:
    """
    Calculates between two molecules using the Tanimoto algorithm

    :param smiles_1: the SMILES string of one molecule
    :param smiles_2: the SMILES string of the other molecule
    :return Tanimoto_similarity: a number between 0 and 1 that quantifies the Tanimoto similarity between two molecules
    """

    mol1 = Chem.MolFromSmiles(smiles_1)
    mol2 = Chem.MolFromSmiles(smiles_2)
    mfpgen = rdFingerprintGenerator.GetMorganGenerator(radius=2,fpSize=2048)
    fp1 = mfpgen.GetFingerprint(mol1)
    fp2 = mfpgen.GetFingerprint(mol2)

    Tanimoto_similarity = DataStructs.TanimotoSimilarity(fp1, fp2)

    return Tanimoto_similarity

def calculate_MCS_similarity(smiles_1:str,
                             smiles_2: str) -> float:
    '''
    Calculates the similarity between two molecules using the Maximum Common Substructure (MCS) algorithm

    :param smiles_1: the SMILES string of one molecule
    :param smiles_2: the SMILES string of another molecule
    :return score: a number between 0 and 1 that quantifies the MCS similarity between the two given molecules
    '''
    mol1 = Chem.MolFromSmiles(smiles_1)
    mol2 = Chem.MolFromSmiles(smiles_2)

    result = rdFMCS.FindMCS([mol1, mol2], timeout=1, matchValences=True, matchChiralTag=False,
                            bondCompare=Chem.rdFMCS.BondCompare.CompareOrderExact)  # search for 1 second max

    if result.canceled:
        print('MCS timeout')
    score = result.numAtoms / (len(mol2.GetAtoms()) + len(mol1.GetAtoms()) - result.numAtoms)

    return score

def simplify_reaction(reaction_smiles: str,
                      reaction_stoich: str) -> str:
    '''
    Converts a reaction into a readable reaction with stoichiometry applied

    :param reaction_smiles: the SMILES string of a reaction generated by DORAnet
    :param reaction_stoich: the stoichiometry of said reaction
    :return rxn_string: a readable reaction string with stoichiometry applied
    '''
    reactants, products = reaction_smiles.split('>>')
    reactant_list = reactants.split('.')
    product_list = products.split('.')

    rxn_string = ''
    reactant_stoich, product_stoich = reaction_stoich.split('$')

    reactant_stoich = reactant_stoich.strip('()')
    reactant_stoich = reactant_stoich.split(',')
    reactant_stoich = list(filter(None, reactant_stoich))

    for i in range(0, len(reactant_list)):
        for j in range(0, int(reactant_stoich[i])):
            rxn_string += reactant_list[i]

            if i < len(reactant_list) - 1:
                rxn_string += ' + '

    rxn_string += ' = '

    product_stoich = product_stoich.strip('()')
    product_stoich = product_stoich.split(',')
    product_stoich = list(filter(None, product_stoich))

    for i in range(0, len(product_list)):
        for j in range(0, int(product_stoich[i])):
            rxn_string += product_list[i]
            if i < len(product_list) - 1:
                rxn_string += ' + '

    return rxn_string

def run_biology(precursor_smiles: str,
                target_name: str,
                target_smiles: str,
                direction: str,
                num_generations: int,
                PKS_design_number: int) -> Tuple[bool, Union[list, dict]]:
    """
    A wrapper to run DORAnet biology and get back pathways

    :param precursor_smiles: SMILES string of top PKS product
    :param target_name: name of the target molecule
    :param target_smiles: SMILES string of target product after bio modifications
    :param direction: direction of the reaction; either forward or reverse
    :param num_generations: number of generations
    :param PKS_design_number: the number associated with the PKS product being biologically expanded upon by DORAnet
    :return pathways_found: a boolean indicating whether biological pathways were successfully found from the PKS
            product to the target metabolite
            pathways_dict: a dictionary of pathways found, with the key being pathway number, and the value being a
            dictionary of reactions, with the reaction number as the key and values as reaction strings
            ranked_metabolites: a list of most MCS similar molecules to the target metabolite that can be produced from
            the given PKS product
    """

    # 1. Ensure precursor SMILES are in their canonical form and without stereochemistry
    precursor_mol = Chem.MolFromSmiles(precursor_smiles)
    if precursor_mol is None:
        raise ValueError(f'Invalid SMILES string: {precursor_smiles}')
    Chem.RemoveStereochemistry(precursor_mol)
    canon_precursor_smiles = Chem.MolToSmiles(precursor_mol)

    # 2. Run DORAnet
    job_name = f'{target_name}_PKS{PKS_design_number}_BIO{num_generations}'

    forward_network = enzymatic.generate_network(
        job_name = job_name,  # name of the job, can be anything
        starters = {f'{canon_precursor_smiles}'},  # starting molecule(s)
        gen = num_generations,  # number of generations
        direction = f'{direction}',  # direction of operators, here forward direction
    )

    # 3. Extract all products from running DORAnet and check if target is present
    # to check if target is present, we must also canonicalize and remove stereo from target_smiles
    # then if we can get a list of metabolites from forward_network, let's check if target is in there

    target_mol = Chem.MolFromSmiles(target_smiles)
    if target_mol is None:
        raise ValueError(f'Invalid SMILES string: {precursor_smiles}')
    Chem.RemoveStereochemistry(target_mol)
    canon_target_smiles = Chem.MolToSmiles(target_mol)

    # 4. When biological pathways that reach the target molecule are found, they are processed into a pathways.txt file,
    # which is parsed through to create a dictionary of pathways compatible as an input for the feasibility classifier.

    try:
        post_processing.one_step(
            networks = {
                forward_network,
            },
            total_generations = num_generations,
            starters = {f'{canon_precursor_smiles}'},
            target = f'{canon_target_smiles}',
            job_name=job_name,
            search_depth=num_generations,
            max_num_rxns=num_generations,
            min_rxn_atom_economy=0,
            num_process=num_generations,
        )
        pathways_found = True
        pathways_dict = {}

        with open(f'{job_name}_pathways.txt', 'r') as file:
            pathway_counter = 0
            lines = file.readlines()
            for i, line in enumerate(file):
                if 'reaction SMILES stoichiometry' in line:
                    pathway_counter += 1
                    reactions_list = []
                    stoich_list = line.strip('reaction SMILES stoichiometry ')
                    stoich_list = stoich_list.lstrip("'[").rstrip("]'\n")
                    stoich_list = stoich_list.split("', '")

                    for j in range(0, len(stoich_list)):
                        reaction = lines[i + j + 2].rstrip('\n')
                        rxn_string = simplify_reaction(reaction, stoich_list[j])
                        reactions_list.append(rxn_string)

                    pathways_dict.update({f'pathway {pathway_counter}': {'reactions (SMILES)': reactions_list}})

        return pathways_found, pathways_dict

    # In the case that pathways are not found, the top 10 most MCS similar molecules to the target molecule are found
    # to provide the user with potential starting points.

    except FileNotFoundError:
        pathways_found = False
        mol_dict = {}
        for mol in forward_network.mols:
            mol_dict[mol.uid] = calculate_MCS_similarity(target_smiles, mol.uid)
        ranked_metabolites = dict(sorted(mol_dict.items(), key = lambda item: item[1], reverse = True))

        i = 0
        print("Top 20 Similarly Ranked Metabolites")
        for mol_uid,Tan_sim in ranked_metabolites.items():
            if i < 11:
                print(f'Rank {i}: {mol_uid} || {Tan_sim}')
            i += 1

        return pathways_found, ranked_metabolites

if __name__ == "__main__":
    run_biology('CCCCCCC(=O)O', 'results_found', 'CCC1CCCC1=O', 'forward',
                2, 4)
